// pkg/helmclient/client.go
package helmclient

import (
	"context"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"time"

	"helm.sh/helm/v3/pkg/action"
	"helm.sh/helm/v3/pkg/chart/loader"
	"helm.sh/helm/v3/pkg/cli"
	"helm.sh/helm/v3/pkg/release"
	"helm.sh/helm/v3/pkg/repo"
)

type HelmClient struct {
	actionConfig *action.Configuration
	settings     *cli.EnvSettings
}

// New 创建 HelmClient 实例
func New(namespace string) (*HelmClient, error) {
	settings := cli.New()
	settings.RepositoryConfig = filepath.Join(os.Getenv("HOME"), ".helm", "repositories.yaml")
	settings.RepositoryCache = filepath.Join(os.Getenv("HOME"), ".helm", "cache")

	actionConfig := new(action.Configuration)
	if err := actionConfig.Init(settings.RESTClientGetter(), namespace, "memory", log.Printf); err != nil {
		return nil, fmt.Errorf("failed to initialize Helm client: %v", err)
	}

	return &HelmClient{
		actionConfig: actionConfig,
		settings:     settings,
	}, nil
}

// AddRepo 添加 Helm 仓库
func (c *HelmClient) AddRepo(name, url, username, password string) error {
	repoEntry := repo.Entry{
		Name:     name,
		URL:      url,
		Username: username,
		Password: password,
	}

	repoFile, err := repo.LoadFile(c.settings.RepositoryConfig)
	if os.IsNotExist(err) {
		repoFile = repo.NewFile()
	} else if err != nil {
		return err
	}

	repoFile.Update(&repoEntry)
	if err := repoFile.WriteFile(c.settings.RepositoryConfig, 0644); err != nil {
		return err
	}

	chartRepo, err := repo.NewChartRepository(&repoEntry, repo.GetHTTPClient())
	if err != nil {
		return err
	}
	_, err = chartRepo.DownloadIndexFile()
	return err
}

// InstallOrUpgrade 安装或升级 Chart
func (c *HelmClient) InstallOrUpgrade(releaseName, chartName, namespace string, values map[string]interface{}) error {
	// 检查是否已存在
	histClient := action.NewHistory(c.actionConfig)
	histClient.Max = 1
	if _, err := histClient.Run(releaseName); err == nil {
		return c.upgrade(releaseName, chartName, namespace, values)
	}
	return c.install(releaseName, chartName, namespace, values)
}

func (c *HelmClient) install(releaseName, chartName, namespace string, values map[string]interface{}) error {
	installClient := action.NewInstall(c.actionConfig)
	installClient.ReleaseName = releaseName
	installClient.Namespace = namespace
	installClient.Wait = true
	installClient.Timeout = 5 * time.Minute

	chartPath, err := installClient.LocateChart(chartName, c.settings)
	if err != nil {
		return err
	}

	chart, err := loader.Load(chartPath)
	if err != nil {
		return err
	}

	_, err = installClient.Run(chart, values)
	return err
}

func (c *HelmClient) upgrade(releaseName, chartName, namespace string, values map[string]interface{}) error {
	upgradeClient := action.NewUpgrade(c.actionConfig)
	upgradeClient.Namespace = namespace
	upgradeClient.Wait = true
	upgradeClient.Timeout = 5 * time.Minute

	chartPath, err := upgradeClient.LocateChart(chartName, c.settings)
	if err != nil {
		return err
	}

	chart, err := loader.Load(chartPath)
	if err != nil {
		return err
	}

	_, err = upgradeClient.Run(releaseName, chart, values)
	return err
}

// ListReleases 列出所有 Release
func (c *HelmClient) ListReleases() ([]*release.Release, error) {
	listClient := action.NewList(c.actionConfig)
	listClient.All = true // 包含所有状态（包括失败）
	return listClient.Run()
}

// GetReleaseStatus 获取指定 Release 状态
func (c *HelmClient) GetReleaseStatus(name string) (string, error) {
	statusClient := action.NewStatus(c.actionConfig)
	rel, err := statusClient.Run(name)
	if err != nil {
		return "", err
	}
	return rel.Info.Status.String(), nil
}

// WatchPodStatus 监控 Release 下 Pod 状态（流式）
func (c *HelmClient) WatchPodStatus(ctx context.Context, releaseName string) (<-chan string, error) {
	statusChan := make(chan string)
	go func() {
		defer close(statusChan)
		ticker := time.NewTicker(10 * time.Second)
		defer ticker.Stop()

		for {
			select {
			case <-ctx.Done():
				return
			case <-ticker.C:
				status, err := c.getReleasePodsStatus(releaseName)
				if err != nil {
					statusChan <- fmt.Sprintf("ERROR: %v", err)
					continue
				}
				statusChan <- status
			}
		}
	}()
	return statusChan, nil
}

// getReleasePodsStatus 内部方法：获取 Pod 状态摘要
func (c *HelmClient) getReleasePodsStatus(releaseName string) (string, error) {
	// 需结合 Kubernetes 客户端实现（略）
	return "Running (3/3)", nil
}
